#해시 테이블
##1. 해시 테이블이란?
우선, 해시 함수(hash function)이란, 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수를 말한다[^1][Figure 1]. 해시 테이블은 해시 함수를 이용해 매우 빠른 데이터 검색을 실현한 자료구조이다. 기존의 자료구조[배열, 리스트 등]은 인덱스나 iterator를 이용해 데이터의 위치를 찾아낸다. 하지만 인덱스나 iterator는 자료구조 안의 데이터 값과 거의 독립적으로 붙여지기 때문에 결국 자료구조의 head부터 하나 하나 찾아나가는 쓸 데 없는 짓(overhead)을 피할 수 없다. 때문에 탐색이나 삽입에 선형시간[배열, 리스트 등] 혹은  O(log n)[이진탐색트리]가 걸리게 된다. 하지만 해시 테이블은 찾고자 하는 데이터로부터 인덱스를 '직접적으로' 계산하기 때문에 훨씬 빠른 속도로 액세스가 가능하다.

![해시함수](https://upload.wikimedia.org/wikipedia/commons/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg)[Figure 1]








##2. 해시 테이블의 기초개념[^2]
데이터를 저장하기 위해 배열 T를 준비한다. 이 때 데이터를 key라고 부른다. key k를 배열 T에 저장할 때, 해시 함수 h를 이용한다. h는 key로부터 0~(N-1)(N은 T의 크기)로의 함수이다. h(k)를 계산하면 배열의 인덱스가 구해지므로 그 곳에 접근해 데이터를 넣기만 하면 된다. 즉, 탐색과 삽입에 필요한 시간은 h(k)를 계산하는 시간에 절대적으로 의존한다. 보통 h는 간단한 함수로 정의하기 때문에 매우 빠른 속도로 탐색, 삽입이 가능하다.[Figure 2]
![해시테이블](http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/222_a.gif)[Figure 2]

###2.1. 충돌(Collision)
충돌은 해시 테이블의 가장 큰 문제점으로, 서로 다른 key값이 동일한 함수값을 가지는 경우를 말한다. 즉, k1 != k2 && h(k1) == h(k2)인 경우이다. 충돌이 발생할 수록 효율이 떨어지기 때문에 충돌을 발생하지 않도록 하거나 충돌이 발생했을 때 잘 대처하는 것이 해시 테이블을 잘 구성하는 방법이다.
###2.2 체이닝(Chaining)
충돌을 최소화하기 위한 방법 중 하나이다. 배열에 삽입되는 데이터들을 연결리스트로 구성해, 충돌이 발생했을 시 연결리스트의 끝에 새로운 노드를 연결한다[Figure 3]. 탐색시간은 리스트의 길이만큼 필요하며, 최악의 경우 연결리스트와 같은 선형시간 O(n)을 갖는다. 평균적으로는 O(a+1)이 걸린다. a는 적재율을 나타낸다[2.3 참조].
![체이닝](http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/223_a.gif)[Figure 3]
###2.3 적재율
적재율이란 현재 저장된 key의 갯수(K)를 테이블의 크기(N)로 나눈 값(K/N)이다. 즉 현재 저장된 데이터가 많을 수록 충돌 확률이 높아져 평균 탐색시간이 늘어나고, 데이터가 적을수록 충돌이 적게 일어나 해시 테이블의 효율이 증가한다.


##3. 여러가지 해시 함수
다양한 해시 함수를 이용해 해시 테이블을 구성하는 것이 가능하다.
###3.1. Direct Addressing
h가 항등함수인 것. 즉, key가 다르면 인덱스도 다르므로 충돌이 일어나지 않는다. 탐색, 삽입, 삭제 등 모두 O(1)으로 처리 가능하다. 단, 배열의 크기가 충분히 커야 한다.[Figure 4]
![DAT](http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/220_a.gif)[Figure 4]
###3.2. 나머지 값을 이용
key를 어떤 수 m으로 나는 나머지를 해쉬값으로 이용한다. 예를 들어 m=100이면 k mod m은 0~99중 하나의 값을 가진다. m은 해시 테이블의 성능을 좌우한다. 보통 m은 키의 수의 3배가 적당하다고 알려져 있다.
보통 m은 소수(prime number)일 때 좋은 성능을 낸다고 한다. 예를 들어 m이 8이면 2진수로 00001000이고, 끝의 세자리 수만이 해시 값에 영향을 준다. 10110100, 10001100은 같은 해시값을 가진다. 즉, '규칙성'이 생기고 충돌이 발생할 확률이 높아진다(내 생각. 확실치않음)
##4. 응용분야
데이터베이스, CPU의 Cache 등
##5. 결론
해시테이블은 넓은 공간을 이용해 계산량을 줄인다. 해시 함수를 잘 정하는 것이 중요하다. 좋은 해시 함수란, 계산이 빠르고, 충돌이 잘 일어나지 않아야 한다. 충돌이 발생 했을 때의 대처법으로는 체이닝 등이 있다(다른 방법도 있지만 여기서는 다루지 않았다).

###부록. 계수정렬(Counting Sort)
입력값의 범위를 알고 있을 때, O(n)으로 정렬할 수 있다. 설명은 다음 예시로 충분하다.
ex)
입력 범위 : 0~9
크기 10의 배열 A를 준비한다.
A     : 0 0 0 0 0 0 0 0 0 0
입력열(列) : 3 5 8 1 2 1 5 9 4 3


0.
3 5 8 1 2 1 5 9 4 3
A : 0 0 0 0 0 0 0 0 0 0

1.
5 8 1 2 1 5 9 4 3
A : 0 0 0 1 0 0 0 0 0 0 

2.
8 1 2 1 5 9 4 3
A : 0 0 0 1 0 1 0 0 0 0

3.
1 2 1 5 9 4 3
A : 0 0 0 1 0 1 0 0 1 0

4.
2 1 5 9 4 3
A : 0 1 0 1 0 1 0 0 1 0

5.
1 5 9 4 3
A : 0 1 1 1 0 1 0 0 1 0

6.
5 9 4 3
A : 0 2 1 1 0 1 0 0 1 0

7.
9 4 3
A : 0 2 1 1 0 2 0 0 1 0

8.
4 3
A : 0 2 1 1 0 2 0 0 1 1

9.
3
A : 0 2 1 1 1 2 0 0 1 1

10.

A : 0 2 1 2 1 2 0 0 1 1

출력: 1 1 2 3 3 4 5 5 8 9
[^1]: https://ko.wikipedia.org/wiki/해시_함수
[^2]: http://hsp1116.tistory.com/35
